<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../webda-webcomponents/webda-core.html">
<script>
if (!Webda.Models) {
  Webda.Models = {'Widgets': {
                    'string': 'webda-model-string', // JSON Schema default
                    'number': 'webda-model-number', // JSON Schema default
                    'integer': 'webda-model-number', // JSON Schema default
                    'array': 'webda-model-array',  // JSON Schema default
                    'boolean': 'webda-model-boolean',  // JSON Schema default
                    'object': 'webda-model-object',  // JSON Schema default
                    'html': 'webda-model-html',
                    'list': 'webda-model-list',
                    'date': 'webda-model-date',
                    'markdown': 'webda-model-markdown'
                }, 'Schemas': {}};
}
/**
 * Behavior that handle the JSON Schema.
 *
 * @polymerBehavior
 * @demo demo/index.html
 */
Webda.Behaviors.ModelDisplay = {
  properties: {
    /**
     * JSON Schema to display/edit
     *
     * See http://json-schema.org/ for definition
     */
    schema: {
      type: Object
    },
    /**
     * Object to display accordingly to the schema previously defined
     *
     * If in edit mode this will represent the answer of the form
     */
    value: {
      type: Object,
      notify: true
    },
    /**
     * Define if it display the data or edit the data
     */
    editMode: {
      type: Boolean,
      observer: '_generateModelWidgets'
    },
    /**
     * Map of widgets to use per property
     *
     * By default, it will look if the $ref attribute of the property is found inside the map,
     * It will then fallback on the type if not found
     *
     * The default map used is register in Webda.Models.Widgets
     *
     * 'string': 'webda-model-string'
     *
     * 'number': 'webda-model-number'
     *
     * 'integer': 'webda-model-number'
     *
     * 'array': 'webda-model-array'
     *
     * 'boolean': 'webda-model-boolean'
     *
     * 'object': 'webda-model-object'
     *
     */
    typeWidgets: {
      type: Object,
      value: function() {
        return Webda.Models.Widgets;
      }
    }
  },

  ready: function() {
    if (!this.schema) return;
    this._generateModelWidgets();
  },

  _generateTypeWidget: function(prop) {
    // Get definition
    var definition = this.schema.properties[prop];
    var type;

    // First check for $req then fallback to basic type
    if (definition.$req) {
      type = this.typeWidgets[definition.$req];
    }
    if (!type) {
      type = this.typeWidgets[definition.type];
    }
    if (type === undefined) {
      console.log("No widget is configured for", definition);
      return;
    }

    // Prepare element attributes
    var attrs = {};
    attrs.editMode = this.editMode;
    this._getModelElementAttributes(prop, attrs);
    if (!attrs.value && definition.type === "object") {
      attrs.value = {};
    }
    // If no title is set then add the property name as title
    if (attrs.schema.title === undefined) {
      attrs.schema.title = prop;
    }
    // Create the element
    var el = this.create(this.typeWidgets[definition.type], attrs);
    el.addEventListener('value-changed', (evt) => {
      if (evt.info) {
        return;
      }
      evt.info = this.tagName;
      this._updateModelValue(prop, evt.detail.value);
    });
    if ((definition.type === 'object' || definition.type === 'array') && el._generateModelWidgets) {
      el._generateModelWidgets();
    }
    return el;
  },

  _getModelElementAttributes: function(prop, attrs) {
    // If a value is set for this property forward it
    if (this.value[prop]) {
      attrs.value = this.value[prop];
    }
    attrs.schema = this.schema.properties[prop];
  },

  _updateModelValue: function(prop, value) {
    // Update property
    this.value[prop] = value;
    // Send the value-changed for update
    this.fire('value-changed', {'value':this.value});
  },

  _generateModelWidgets: function() {
    // If no schema nothing to generate
    if (this.schema === undefined) {
      return;
    }
    var content;
    // If a tag with id content exists use it, use root in other case
    if (this.$ && this.$.content) {
      while (this.$.content.firstChild) {
        this.$.content.removeChild(this.$.content.firstChild);
      }
      content = this.$.content;
    } else {
      content = Polymer.dom(this.root);
      while (content.firstChild) {
        content.removeChild(content.firstChild);
      }
      content = content.node;
    }

    // Add the widget according to the properties
    for (var prop in this.schema.properties) {
      Polymer.dom(content).appendChild(this._generateTypeWidget(prop));
    }
  }
};
</script>
